# Don't overthink it

Claude is cheap.

Some interesting things happen when you can generate a whole implementation in 10 minutes. My initial reaction was to put a  lot of emphasis on the "spec document". The idea was that if you can just get the spec right, you can oneshot a perfect implementation.

I just tried doing this for the past few days - when setting up the cake migration to lifecycle nodes, I spent literally 2 days going back and forth with claude on a "planning, migration and design" document, which was supposed to represent the design choices for the migration, as well as set up an implementation plan. It sorta worked, but it probably wasn't the most efficient way to do it.

Here's what happened - I spent two days tweaking things, getting claude (and myself) to "think through" the implications of certain choices, updating the doc accordingly. I also tried this neat trick of getting it to "read through the document and point out any inconsistencies" - which worked quite well at surfacing potential issues in the design. However, it may have also just produced busy work. The main problem with this approach, is a design document is not an implementation.

Once I was happy with the design doc (I was kind of still feeling like there was more that could have been refined, but I was also sick of working on a doc and not code) I tried to be a bit fancy. I got claude to split it up into "phases" and then i manually tried to prompt our friend claude to implement each of these phases in a new session (sequentially). This was a clusterfuck, I think because it didn't have the context of decisions made in the previous phase - it was just left with the code (which was also a bit badly split into phases imo, but I was lazy and just yoloed it with what i got). I think the code was kinda all there, but i couldn't really keep a track of everything and i couldn't be sure what the hell had just happened. Also the "build, test, iterate" loop that claude has going for it didn't work here because the phases were split so that "phase 1" left the codebase in a non-working state (again, bad phase design). I decided this attempt was a fail, but luckily each phase only took like 10 minutes, so I hadn't lost very much time. Nuked that implementation.

Next I just lobbed the whole design doc at plan mode, skimmed the plan for anything obviously wrong and hit accept all. This was better - I think since the build test loop was kept more in tact, and that everything relevant was in one context. I got a working implmentation (I think - I didnt fully test it) out of this method, so yay. I didn't fully test it, because as I was looking through the code, it became clear to me that I had fucked up a design choice. It wasnt an implementation fuck up, but a high level architecture thing that would make me sad later. No matter though - I was only 10 minutes into this code, so cya. Nuked that one as well.

Taking what I had learned from the code (_interesting note: i had only realised it from the code, not the design doc_), I did a little back and forth to redesign the design doc to use a better design pattern. Then - back on the grind: lob that at plan mode, check for dumbassery, accept all and go get a coffee.

This left me with a "pretty good" implementation. This was not the end though - reviewing the code, I found another issue I didn't like (the memory model ownership stuff I talked about yesterday). However, this was not as fundamental as the previous issue and a bulk of the migration to lifecycle was complete, and seemed pretty good. So I figured I would just treat this as a standard change to the implementation - same as any other you would normally make. Started off pitching the idea to claude, going back and forward refining the concept and then bumped it into plan mode. Again, a bulk of the work was in ironing out the idea up front, but learning from last time I decided to bias towards moving the process forwards and checking if it worked with code. I actually can't remember if I nuked a version after this or not (could probably check the commits but ceebs), but eventually I was at the point where I was happy with the c++ implementation of cake, migrated to lifecycle nodes.

The last piece of the story is doing the python implementation today. Learning from my previous attempts, I decided to go for a more "just generate the code" approach - prompting claude to take into account the current state of the c++, the current state of the python (and their differences), plus the original design doc (which had only talked about a c++ migration) and make a plan to migrate the python implementation. This worked quite well - but again there were a bunch of things that needed changing. Nothing fundamentally structural though (i think we inherited the good architectural ideas by referencing the c++ version and the design doc), so I stuck with the incremental improvements approach. Which leads us to now - where the migration is mostly complete, barring a few more extra features that need to be added.

## That was a lot of yapping, big man

ok champ. Here's what I think the point is:

My original instinct when I realised I could "oneshot" full working implementations was to try and get the prompt /plan perfect so that the code was "perfect" first try.

Turns out, a) LLMs are nondeterministic, so like, you could just get some nonsense one time and b) this is a rather inefficient way to do it. It's inefficient because:
- I was so focused on getting every single detail right, I missed a bigger picture detail
- your design documents become incomprehensible to humans (and I guess eventually to LLMs as well if big enough)
- a design is not an implementation, if it was, it would be an implementation
- I am better at reading and evaluating code than I am at evaluating a paragraph describing that code

Instead, a better approach is to get a higher level design nailed down, with what you think are the key points that really matter. Then, smack that bad boy into the chat box and let those GPUs run a river dry. The output will probably be more informative than if you had noodled around with a detailed plan. If the implementation you get is cooked - that's ok. If you think its worth just trying it again in a new session, do that. Otherwise you have new information to refine your original prompt. Finally, once you get it close enough, then you can start doing incremental changes to get to where you need to be.

Hilariously, I'm sure this is probably like a named, documented process for humans to follow too. Is this just AgIlE BuT FoR LlMs... I think i also remember something in the Mythical Man Month about "planning to throw one out" - which is a similar idea.

Anyways, thats that for today.

ciao