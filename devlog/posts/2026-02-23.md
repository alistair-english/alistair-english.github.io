# I am the captain still

And claude is still the copilot.

Today I sunk a decent amount of time into figuring out the memory model and ownership semantics for cake. The model I have been chasing is one which effectively constrains the ROS2 node to be a part of the "executable" that is run by `ros2 run` - rather than a _being_ the executable. A _has a_ relationship rather than an _is a_, if you will.

The way I've done this, is creating a "BaseNode" (its not a node, it "has" a node - but node is overloaded to mean too many things so it kind of needs to just be called a node) which holds an instance of a ROS node. It delegates that node to the executor for running and also provides the node to a user setup function, which moves user code out of the node constructor and into a free function (win). The user setup code then uses that node reference to create publishers, subscribers etc.

To avoid the user putting _state_ on the node (they can't anyway - they don't get to edit its implementation), we provide a `Context` object, which holds a shared pointer to the node, plus is templated to allow the user to subclass it and add extra implementation-specific stuff to it. We create one instance of the `Context` object in base node and pass that to the user functions through a shared ptr. Essentially, it becomes a global store of state, instead of the member variables of your node class (win).

This works great in the versions of cake _before_ lifecycle nodes (which I am now migrating cake to use) because there no concept of a lifetime. The node and the context are created, and they live forever until the whole node shuts down or is killed. Simples. The problem with lifecycle nodes, is they introduce, well, lifecycles - and now our `Context` needs to respect those cycles. At the root of it, `Context` now needs to reflect the states that the lifecycle node imposes - `Unconfigured`, `Inactive`, `Active`, `Finalized`.

Initally, my (and claudes) idea was to keep the same model of having "one instance" of the context, and let it get mutated around according to the node state. This was fine, until it results in code like this:
```cpp
void reset_context() {
    *ctx_ = ContextType{};
    ctx_->node = node;
  }
```

I don't like this because it semantically puts ctx_ in an invalid state - there is a point at which ctx_->node is `null` - which is never true, because if the code is running, there is a node somewhere that we should know about.

As a result, there was a lot of noodling around trying on different ideas and exploring the limitations of what `Context` should be - which landed us at the realisation that if we are keeping `Context` around, but trying to "reset" it (which is an all-or-none operation) then "node" can't really live on it - downstream consumers should have a separate reference to `node` which has its own semantics (i.e. as far as they are concerned node is omnipresent). Interestingly, this freed us up to think about the fact that then, what is the point of keeping `Context` alive and resetting it - it basically lives for one cycle of a lifecycle. Probably then the name is misleading (or at least, uninformative) - so enter `Session`. An object which stores node state, but is created `on_configure` and destroyed `on_cleanup` (or `on_shutdown`).

Now that we have a clear definition of the life of `Session`, we can also make another move for convenience - put a reference to `node` back into `Session`. This is because we know that node will be always be around at session construction time and we are just nuking sessions at the end of their run, instead of trying to "reset" them. Another sticky situation we were in with `Context` was that entities (publishers, subscribers etc) were capturing a weak_ptr to the context, so that it could be passed into their callback. Weak ptr provided us some protection that the context was still around - we could try `.lock`ing it and if we didnt get anything back, assume the context is dead and just no-op the callback. But this didn't really do anything, because we never really killed the `Context` just reset it, and it was possible that context was in a borked state (node=null), but we would still just get the context from that lock (bad vibes). The nice thing about session is that this doesn't happen, because we properly thought through the lifetime of our object - when session is alive, it holds a valid reference to a node and when its dead, he ded - cant do anything. Much better.

## So what you fucking nerd

Yeah ok, so technically the other design would have worked. The borked state can only happen with a multi-threading executor that wasn't syncronised properly. But it gave me _bad vibes_. I don't fully know how to explain it other than its kinda like a "code smell". To me it signaled that I (_and claude_) hadn't fully understood what we were doing, and that our logical representation had flaws in it.

I hate working with code that gives me bad vibes. I think because you can feel when there are logical inconsistencies. Things that should be easy, become hard but you can't quite put a finger on the root cause. Its just gets confusing for no reason.

### Who cares, just vibecode it

Tbh kinda true. But also nah. My hypothesis (ungrounded in any scientific process) is that LLMs have been trained to "think" ("reason"?) in the same way as humans. They are gigabrain about it (they can hold more "instantaneous context" in their "heads" than we can?), but at a large enough scale they run into the same reasoning traps that humans do. The point is - I think keeping code well organised, modular and logically consistent (things we do to help our pathetic human brains grasp what is going on) are tricks that are still necessary at large enough scale when using LLMs.

## What's with the cringe title

Oh yeah so - to tie this all up. Claude didn't get bad vibes. It was perfectly happy to just push ahead with the old implementation. I was the one that had to be like "this doesn't feel right" and push back on the design. I am still the captain because I decide what passes the vibe check. There's probably smarter sounding phrases involving words like "architecture" or something. 

Sure, I ain't writing the `if` statements much any more, but until claude says "actually that perfectly functional implementation has bad vibes":

_look at me_

_im (still) the captain now_




